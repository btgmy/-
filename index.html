<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>机器学习题库（支持单选/多选/简答）</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", Arial, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }

            .header h1 {
                color: #2c3e50;
                margin-bottom: 10px;
            }

            .header p {
                color: #7f8c8d;
                font-size: 16px;
            }

        .stats-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .stat-item {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            font-size: 14px;
            color: #34495e;
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 25px;
            align-items: center;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            position: relative;
        }

            .search-box input {
                width: 100%;
                padding: 10px 15px;
                border: 1px solid #ddd;
                border-radius: 20px;
                font-size: 14px;
                outline: none;
                transition: all 0.3s ease;
            }

                .search-box input:focus {
                    border-color: #3498db;
                    box-shadow: 0 0 0 2px rgba(52,152,219,0.2);
                }

        .filter-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 25px;
            justify-content: center;
        }

        .filter-btn {
            padding: 8px 18px;
            border: none;
            border-radius: 20px;
            background-color: #fff;
            color: #34495e;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

            .filter-btn.active {
                background-color: #3498db;
                color: #fff;
                box-shadow: 0 2px 8px rgba(52,152,219,0.3);
            }

            .filter-btn:hover:not(.active) {
                background-color: #f1f5f9;
            }

        .action-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background-color: #2ecc71;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

            .action-btn:hover {
                background-color: #27ae60;
            }

            .action-btn.secondary {
                background-color: #95a5a6;
            }

                .action-btn.secondary:hover {
                    background-color: #7f8c8d;
                }

        .question-list {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .question-card {
            background-color: #fff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.07);
            transition: transform 0.3s ease;
        }

            .question-card:hover {
                transform: translateY(-3px);
            }

        .question-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .question-type {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
        }

        .type-single {
            background-color: #3498db; /* 单选-蓝色 */
        }

        .type-multiple {
            background-color: #2ecc71; /* 多选-绿色 */
        }

        .type-essay {
            background-color: #e67e22; /* 简答-橙色 */
        }

        .question-id {
            color: #95a5a6;
            font-size: 14px;
        }

        .question-title {
            color: #2c3e50;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .options {
            margin-bottom: 20px;
            padding-left: 10px;
        }

        .option-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 10px;
            color: #34495e;
            font-size: 15px;
            line-height: 1.5;
        }

            .option-item input {
                margin-top: 4px;
                accent-color: #3498db;
            }

        .btn-group {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .show-answer-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background-color: #27ae60;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

            .show-answer-btn:hover {
                background-color: #219653;
            }

        .mark-wrong-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background-color: #e74c3c;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

            .mark-wrong-btn:hover {
                background-color: #c0392b;
            }

        .answer-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #eee;
            display: none;
        }

            .answer-container.show {
                display: block;
            }

        .answer-label {
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 8px;
            display: inline-block;
        }

        .answer-content {
            color: #34495e;
            font-size: 15px;
            line-height: 1.6;
        }

        .category-tag {
            display: inline-block;
            padding: 3px 8px;
            background-color: #f1f5f9;
            color: #64748b;
            font-size: 12px;
            border-radius: 4px;
            margin-left: auto;
        }

        .mode-indicator {
            display: inline-block;
            padding: 4px 10px;
            background-color: #f39c12;
            color: #fff;
            font-size: 12px;
            border-radius: 4px;
            margin-left: 10px;
        }

        /* 响应式调整 */
        @media (max-width: 768px) {
            .question-card {
                padding: 15px;
            }

            .question-title {
                font-size: 15px;
            }

            .option-item {
                font-size: 14px;
            }

            .filter-btn {
                padding: 6px 14px;
                font-size: 13px;
            }

            .control-panel {
                flex-direction: column;
                align-items: stretch;
            }

            .search-box {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>机器学习题库</h1>
            <p>包含单选、多选、简答题型，共 146 题 | 点击筛选题型，查看答案</p>
        </div>

        <!-- 统计信息栏 -->
        <div class="stats-bar">
            <div class="stat-item">总题数: <span id="totalCount">146</span></div>
            <div class="stat-item">单选题: <span id="singleCount">100</span></div>
            <div class="stat-item">多选题: <span id="multipleCount">30</span></div>
            <div class="stat-item">简答题: <span id="essayCount">16</span></div>
            <div class="stat-item">错题数: <span id="wrongCount">0</span></div>
        </div>

        <!-- 控制面板 -->
        <div class="control-panel">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="搜索题目...">
            </div>
            <button class="action-btn" id="randomBtn">随机选题</button>
            <button class="action-btn secondary" id="wrongQuestionsBtn">查看错题</button>
            <button class="action-btn secondary" id="practiceModeBtn">练习模式</button>
        </div>

        <!-- 题型筛选栏 -->
        <div class="filter-bar">
            <button class="filter-btn active" data-type="all">全部题型</button>
            <button class="filter-btn" data-type="single">单选题</button>
            <button class="filter-btn" data-type="multiple">多选题</button>
            <button class="filter-btn" data-type="essay">简答题</button>
        </div>

        <!-- 题目列表 -->
        <div class="question-list" id="questionList">
            <!-- 题目将通过 JS 动态渲染 -->
        </div>
    </div>

    <script>
        // 完整题库数据
        const questionBank = [
            // 单选题（1-100题）
            {
                "id": 1,
                "type": "single",
                "title": "什么是人工智能的核心目标？",
                "options": ["创建智能机器", "提高计算机性能", "优化网络速度", "增强数据存储"],
                "answer": "创建智能机器",
                "category": "人工智能基础"
            },
            {
                "id": 2,
                "type": "single",
                "title": "机器学习的主要类型不包括以下哪一项？",
                "options": ["监督学习", "无监督学习", "半监督学习", "超监督学习"],
                "answer": "超监督学习",
                "category": "机器学习分类与算法"
            },
            {
                "id": 3,
                "type": "single",
                "title": "以下哪项不是深度学习的一个应用？",
                "options": ["图像识别", "自然语言处理", "数据清洗", "语音识别"],
                "answer": "数据清洗",
                "category": "深度学习与神经网络"
            },
            {
                "id": 4,
                "type": "single",
                "title": "在机器学习中，什么是过拟合？",
                "options": ["模型在训练数据上表现不佳", "模型在测试数据上表现不佳", "模型在训练数据上表现良好，但在新数据上表现不佳", "模型在所有数据上表现一致"],
                "answer": "模型在训练数据上表现良好，但在新数据上表现不佳",
                "category": "模型训练与评估"
            },
            {
                "id": 5,
                "type": "single",
                "title": "以下哪种算法是监督学习算法？",
                "options": ["K-均值聚类", "决策树", "主成分分析", "关联规则学习"],
                "answer": "决策树",
                "category": "机器学习分类与算法"
            },
            {
                "id": 6,
                "type": "single",
                "title": "在神经网络中，激活函数的主要作用？",
                "options": ["增加网络的复杂性", "减少网络的计算量", "引入非线性特性", "提高网络的稳定性"],
                "answer": "引入非线性特性",
                "category": "深度学习与神经网络"
            },
            {
                "id": 7,
                "type": "single",
                "title": "以下哪项技术不是用于防止过拟合的？",
                "options": ["正则化", "交叉验证", "数据增强", "数据清洗"],
                "answer": "数据清洗",
                "category": "模型训练与评估"
            },
            {
                "id": 8,
                "type": "single",
                "title": "什么是强化学习中的“奖励”？",
                "options": ["模型预测的准确性", "模型在特定任务上的表现", "模型在训练过程中的反馈", "模型在测试集上的错误率"],
                "answer": "模型在训练过程中的反馈",
                "category": "强化学习"
            },
            {
                "id": 9,
                "type": "single",
                "title": "在自然语言处理中，什么是词嵌入？",
                "options": ["将词语转换为数字向量", "将句子转换为数字向量", "将文档转换为数字向量", "将词语转换为图像"],
                "answer": "将词语转换为数字向量",
                "category": "自然语言处理基础"
            },
            {
                "id": 10,
                "type": "single",
                "title": "以下哪种方法不是用于提高模型泛化能力的？",
                "options": ["增加数据量", "使用更多的特征", "使用正则化技术", "进行交叉验证"],
                "answer": "使用更多的特征",
                "category": "模型训练与评估"
            },
            {
                "id": 11,
                "type": "single",
                "title": "卷积神经网络（CNN）的主要应用领域？",
                "options": ["图像处理", "文本分析", "声音识别", "数据挖掘"],
                "answer": "图像处理",
                "category": "深度学习与神经网络"
            },
            {
                "id": 12,
                "type": "single",
                "title": "在机器学习项目中，数据预处理的主要步骤不包括以下哪一项？",
                "options": ["数据清洗", "数据集成", "数据变换", "数据存储"],
                "answer": "数据存储",
                "category": "数据处理与特征工程"
            },
            {
                "id": 13,
                "type": "single",
                "title": "以下哪项不是评估机器学习模型性能的常用指标？",
                "options": ["准确率", "召回率", "F1分数", "平均值"],
                "answer": "平均值",
                "category": "模型训练与评估"
            },
            {
                "id": 14,
                "type": "single",
                "title": "什么是集成学习？",
                "options": ["使用单一模型进行学习", "使用多个模型进行学习", "使用单一算法进行学习", "使用多个算法进行学习"],
                "answer": "使用多个模型进行学习",
                "category": "机器学习分类与算法"
            },
            {
                "id": 15,
                "type": "single",
                "title": "在机器学习中，什么是特征选择？",
                "options": ["选择最重要的特征", "增加新的特征", "删除无关的特征", "优化特征的表示"],
                "answer": "选择最重要的特征",
                "category": "数据处理与特征工程"
            },
            {
                "id": 16,
                "type": "single",
                "title": "以下哪种算法是基于概率的机器学习算法？",
                "options": ["支持向量机", "随机森林", "朴素贝叶斯", "梯度提升机"],
                "answer": "朴素贝叶斯",
                "category": "机器学习分类与算法"
            },
            {
                "id": 17,
                "type": "single",
                "title": "在深度学习中，什么是梯度消失问题？",
                "options": ["梯度变得非常大", "梯度变得非常小", "梯度保持不变", "梯度随机变化"],
                "answer": "梯度变得非常小",
                "category": "深度学习与神经网络"
            },
            {
                "id": 18,
                "type": "single",
                "title": "以下哪项技术不是用于解决梯度消失问题的？",
                "options": ["使用ReLU激活函数", "使用批量归一化", "使用Sigmoid激活函数", "使用残差网络"],
                "answer": "使用Sigmoid激活函数",
                "category": "深度学习与神经网络"
            },
            {
                "id": 19,
                "type": "single",
                "title": "什么是迁移学习？",
                "options": ["在不同任务间迁移数据", "在不同任务间迁移模型", "在不同任务间迁移算法", "在不同任务间迁移特征"],
                "answer": "在不同任务间迁移模型",
                "category": "机器学习分类与算法"
            },
            {
                "id": 20,
                "type": "single",
                "title": "在机器学习中，什么是交叉验证？",
                "options": ["使用单一数据集进行验证", "使用多个数据集进行验证", "将数据集分成多个部分，多次进行训练和验证", "将数据集分成两个部分，一次进行训练和验证"],
                "answer": "将数据集分成多个部分，多次进行训练和验证",
                "category": "模型训练与评估"
            },
            {
                "id": 21,
                "type": "single",
                "title": "以下哪种方法不是用于处理不平衡数据集的？",
                "options": ["过采样", "欠采样", "合成少数类过采样技术（SMOTE）", "增加数据量"],
                "answer": "增加数据量",
                "category": "数据处理与特征工程"
            },
            {
                "id": 22,
                "type": "single",
                "title": "什么是生成对抗网络（GAN）？",
                "options": ["一种用于生成数据的网络", "一种用于分类数据的网络", "一种用于回归数据的网络", "一种用于聚类数据的网络"],
                "answer": "一种用于生成数据的网络",
                "category": "深度学习与神经网络"
            },
            {
                "id": 23,
                "type": "single",
                "title": "在机器学习中，什么是超参数？",
                "options": ["模型训练过程中学习的参数", "模型训练过程中固定的参数", "模型训练过程中变化的参数", "模型训练过程中优化的参数"],
                "answer": "模型训练过程中固定的参数",
                "category": "模型训练与评估"
            },
            {
                "id": 24,
                "type": "single",
                "title": "以下哪种方法不是用于调整超参数的？",
                "options": ["网格搜索", "随机搜索", "贝叶斯优化", "数据清洗"],
                "answer": "数据清洗",
                "category": "模型训练与评估"
            },
            {
                "id": 25,
                "type": "single",
                "title": "什么是强化学习中的“策略”？",
                "options": ["模型在特定任务上的表现", "模型在训练过程中的反馈", "模型在测试集上的错误率", "模型在特定环境下采取的行动"],
                "answer": "模型在特定环境下采取的行动",
                "category": "强化学习"
            },
            {
                "id": 26,
                "type": "single",
                "title": "在机器学习中，什么是监督学习？",
                "options": ["使用标记数据进行学习", "使用未标记数据进行学习", "使用半标记数据进行学习", "使用无标记数据进行学习"],
                "answer": "使用标记数据进行学习",
                "category": "机器学习分类与算法"
            },
            {
                "id": 27,
                "type": "single",
                "title": "以下哪种算法是无监督学习算法？",
                "options": ["线性回归", "逻辑回归", "K-均值聚类", "支持向量机"],
                "answer": "K-均值聚类",
                "category": "机器学习分类与算法"
            },
            {
                "id": 28,
                "type": "single",
                "title": "什么是深度学习中的“层”？",
                "options": ["数据处理的单元", "数据存储的单元", "数据输入的单元", "数据输出的单元"],
                "answer": "数据处理的单元",
                "category": "深度学习与神经网络"
            },
            {
                "id": 29,
                "type": "single",
                "title": "在机器学习中，什么是特征工程？",
                "options": ["选择最重要的特征", "增加新的特征", "删除无关的特征", "优化特征的表示"],
                "answer": "优化特征的表示",
                "category": "数据处理与特征工程"
            },
            {
                "id": 30,
                "type": "single",
                "title": "以下哪种方法不是用于提高模型鲁棒性的？",
                "options": ["增加数据量", "使用更多的特征", "使用正则化技术", "进行数据清洗"],
                "answer": "进行数据清洗",
                "category": "模型训练与评估"
            },
            {
                "id": 31,
                "type": "single",
                "title": "什么是强化学习中的“状态”？",
                "options": ["模型在特定任务上的表现", "模型在训练过程中的反馈", "模型在测试集上的错误率", "模型在特定环境下的情况"],
                "answer": "模型在特定环境下的情况",
                "category": "强化学习"
            },
            {
                "id": 32,
                "type": "single",
                "title": "在机器学习中，什么是无监督学习？",
                "options": ["使用标记数据进行学习", "使用未标记数据进行学习", "使用半标记数据进行学习", "使用无标记数据进行学习"],
                "answer": "使用未标记数据进行学习",
                "category": "机器学习分类与算法"
            },
            {
                "id": 33,
                "type": "single",
                "title": "以下哪种算法是半监督学习算法？",
                "options": ["线性回归", "逻辑回归", "K-均值聚类", "标签传播算法"],
                "answer": "标签传播算法",
                "category": "机器学习分类与算法"
            },
            {
                "id": 34,
                "type": "single",
                "title": "下列哪位是人工智能之父？",
                "options": ["Marniv Lee Minsky", "Herbert A. Simon", "Allen Newell", "John Clifford Shaw"],
                "answer": "Marniv Lee Minsky",
                "category": "人工智能基础"
            },
            {
                "id": 35,
                "type": "single",
                "title": "下列描述无监督学习错误的是？",
                "options": ["无标签", "核心是聚类", "不需要降维", "具有很好的解释性"],
                "answer": "不需要降维",
                "category": "机器学习分类与算法"
            },
            {
                "id": 36,
                "type": "single",
                "title": "下列描述有监督学习错误的是？",
                "options": ["有标签", "核心是分类", "所有数据都相互独立分布", "分类原因不透明"],
                "answer": "所有数据都相互独立分布",
                "category": "机器学习分类与算法"
            },
            {
                "id": 37,
                "type": "single",
                "title": "下列哪种归纳学习采用符号表示方式？",
                "options": ["经验归纳学习", "遗传算法", "联接学习", "强化学习"],
                "answer": "经验归纳学习",
                "category": "机器学习分类与算法"
            },
            {
                "id": 38,
                "type": "single",
                "title": "SVM算法的性能取决于？",
                "options": ["核函数的选择", "核函数的参数", "软间隔参数", "以上所有"],
                "answer": "以上所有",
                "category": "机器学习分类与算法"
            },
            {
                "id": 39,
                "type": "single",
                "title": "SVM中的代价参数C表示什么？",
                "options": ["在分类准确性和模型复杂度之间的权衡", "交叉验证的次数", "以上都不对", "用到的核函数"],
                "answer": "在分类准确性和模型复杂度之间的权衡",
                "category": "机器学习分类与算法"
            },
            {
                "id": 40,
                "type": "single",
                "title": "下列有关支持向量机说法不正确的是？",
                "options": ["得到的是局部最优解", "具有很好的推广能力", "是凸二次优化问题", "采用结构风险最小化原理"],
                "answer": "得到的是局部最优解",
                "category": "机器学习分类与算法"
            },
            {
                "id": 41,
                "type": "single",
                "title": "下列有关核函数不正确的是？",
                "options": ["可以采用cross-validation方法选择最佳核函数", "满足Mercer条件的函数不一定能作为支持向量机的核函数", "极大地提高了学习机器的非线性处理能力", "函数与非线性映射并不是一一对应的关系"],
                "answer": "满足Mercer条件的函数不一定能作为支持向量机的核函数",
                "category": "机器学习分类与算法"
            },
            {
                "id": 42,
                "type": "single",
                "title": "一对一法分类器，k个类别需要多少个SVM？",
                "options": ["k(k-1)/2", "k(k-1)", "k", "k!"],
                "answer": "k(k-1)/2",
                "category": "机器学习分类与算法"
            },
            {
                "id": 43,
                "type": "single",
                "title": "有关聚类分析说法错误的是？",
                "options": ["无须有标记的样本", "可以用于提取一些基本特征", "可以解释观察数据的一些内部结构和规律", "聚类分析一个簇中的数据之间具有高差异性"],
                "answer": "聚类分析一个簇中的数据之间具有高差异性",
                "category": "机器学习分类与算法"
            },
            {
                "id": 44,
                "type": "single",
                "title": "两个n维向量α(x₁₁,x₁₂,⋯,x₁ₙ)和β(x₂₁,x₂₂,⋯,x₂ₙ)之间的欧式距离为？",
                "options": ["d₁₂=√[(α-β)(α-β)ᵀ]", "d₁₂=∑ₖ₌₁ⁿ|x₁ₖ-x₂ₖ|", "d₁₂=max(|x₁ᵢ-x₂ᵢ|)", "cos(θ)=(α∙β)/(|α||β|)"],
                "answer": "d₁₂=√[(α-β)(α-β)ᵀ]",
                "category": "数据处理与特征工程"
            },
            {
                "id": 45,
                "type": "single",
                "title": "闵可夫斯基距离表示为曼哈顿距离时p为？",
                "options": ["1", "2", "3", "4"],
                "answer": "1",
                "category": "数据处理与特征工程"
            },
            {
                "id": 46,
                "type": "single",
                "title": "关于K-means说法不正确的是？",
                "options": ["算法可能终止于局部最优解", "簇的数目k必须事先给定", "对噪声和离群点数据敏感", "适合发现非凸形状的簇"],
                "answer": "适合发现非凸形状的簇",
                "category": "机器学习分类与算法"
            },
            {
                "id": 47,
                "type": "single",
                "title": "k中心点算法每次迭代的计算复杂度是多少？",
                "options": ["O(1)", "O(k)", "O(nk)", "O(k(n-k)²)"],
                "answer": "O(k(n-k)²)",
                "category": "机器学习分类与算法"
            },
            {
                "id": 48,
                "type": "single",
                "title": "假设某事件发生的概率为p，则此事件发生的几率为？",
                "options": ["p", "1-p", "p/(1-p)", "(1-p)/p"],
                "answer": "p/(1-p)",
                "category": "机器学习分类与算法"
            },
            {
                "id": 49,
                "type": "single",
                "title": "贝叶斯网络起源于贝叶斯统计学，是以什么为基础的有向图模型？",
                "options": ["线性代数", "逻辑学", "概率论", "信息论"],
                "answer": "概率论",
                "category": "机器学习分类与算法"
            },
            {
                "id": 50,
                "type": "single",
                "title": "下列哪项说法不正确？",
                "options": ["人工智能是对人类智能的模拟", "人工神经元是对生物神经元的模拟", "生物神经信号由树突传递给轴突", "人工神经元的激活函数可以有多种设计"],
                "answer": "生物神经信号由树突传递给轴突",
                "category": "人工智能基础"
            },
            {
                "id": 51,
                "type": "single",
                "title": "强化学习基本要素有哪些？",
                "options": ["状态、动作、奖励", "状态、动作、折扣因子", "动作、折扣因子、奖励", "状态、奖励、探索策略"],
                "answer": "状态、动作、奖励",
                "category": "强化学习"
            },
            {
                "id": 52,
                "type": "single",
                "title": "不需要建模环境，等待真实反馈再进行接下来的动作，这是哪种强化学习算法？",
                "options": ["Model-free方法", "Model-based方法", "Policy-based方法", "Value-based方法"],
                "answer": "Model-free方法",
                "category": "强化学习"
            },
            {
                "id": 53,
                "type": "single",
                "title": "Q-learning属于哪种算法？",
                "options": ["On-policy算法", "Off-policy算法", "Model-based算法", "Value-based算法"],
                "answer": "Off-policy算法",
                "category": "强化学习"
            },
            {
                "id": 54,
                "type": "single",
                "title": "马尔科夫决策过程由哪几个元素来表示？",
                "options": ["状态、动作、转移概率、策略、折扣因子", "状态、动作、转移概率、折扣因子、回报函数", "状态、动作、输入、输出、回报函数", "状态、动作、值、策略、回报函数"],
                "answer": "状态、动作、转移概率、折扣因子、回报函数",
                "category": "强化学习"
            },
            {
                "id": 55,
                "type": "single",
                "title": "如果机器每次训练更新的损耗会比较大，更倾向于选择哪种算法？",
                "options": ["Sarsa", "Q-learning", "两者都可以", "两者都不行"],
                "answer": "Sarsa",
                "category": "强化学习"
            },
            {
                "id": 56,
                "type": "single",
                "title": "关于策略梯度的方法说法正确的是？",
                "options": ["只适用于离散动作空间", "适用于连续动作空间", "策略梯度的方法与DQN中的目标函数一致", "策略梯度的方法通过Q值挑选动作"],
                "answer": "适用于连续动作空间",
                "category": "强化学习"
            },
            {
                "id": 57,
                "type": "single",
                "title": "机器学习的主要目标是什么？",
                "options": ["使机器具备人类的智能", "使机器能够自动学习和改进", "使机器能够模拟人类的思维过程", "使机器能够按照给定的规则执行任务"],
                "answer": "使机器能够自动学习和改进",
                "category": "机器学习基础"
            },
            {
                "id": 58,
                "type": "single",
                "title": "下列哪项不是机器学习算法的分类？",
                "options": ["监督学习", "无监督学习", "半监督学习", "完全手动学习"],
                "answer": "完全手动学习",
                "category": "机器学习分类与算法"
            },
            {
                "id": 59,
                "type": "single",
                "title": "在机器学习中，以下哪项是指学习算法在给定训练集上的表现能力？",
                "options": ["泛化能力", "训练误差", "过拟合", "欠拟合"],
                "answer": "训练误差",
                "category": "模型训练与评估"
            },
            {
                "id": 60,
                "type": "single",
                "title": "哪种机器学习算法通常用于处理回归问题？",
                "options": ["支持向量机（SVM）", "K-近邻（K-NN）", "线性回归", "决策树"],
                "answer": "线性回归",
                "category": "机器学习分类与算法"
            },
            {
                "id": 61,
                "type": "single",
                "title": "深度学习是机器学习的哪个子领域？",
                "options": ["弱学习", "表示学习", "概率学习", "规则学习"],
                "answer": "表示学习",
                "category": "深度学习与神经网络"
            },
            {
                "id": 62,
                "type": "single",
                "title": "在监督学习中，算法尝试从训练数据中学习什么？",
                "options": ["数据的分布", "数据的模式", "输入到输出的映射", "数据的统计特性"],
                "answer": "输入到输出的映射",
                "category": "机器学习分类与算法"
            },
            {
                "id": 63,
                "type": "single",
                "title": "以下哪项是机器学习模型评估中常用的交叉验证方法？",
                "options": ["留出法", "梯度下降", "决策树剪枝", "K-均值聚类"],
                "answer": "留出法",
                "category": "模型训练与评估"
            },
            {
                "id": 64,
                "type": "single",
                "title": "在机器学习中，正则化通常用于解决什么问题？",
                "options": ["数据不足", "过拟合", "欠拟合", "维度灾难"],
                "answer": "过拟合",
                "category": "模型训练与评估"
            },
            {
                "id": 65,
                "type": "single",
                "title": "以下哪项是深度学习中常用的激活函数？",
                "options": ["线性函数", "Sigmoid函数", "逻辑回归", "梯度提升"],
                "answer": "Sigmoid函数",
                "category": "深度学习与神经网络"
            },
            {
                "id": 66,
                "type": "single",
                "title": "在机器学习中，特征工程主要关注什么？",
                "options": ["数据的收集", "数据的清洗", "从原始数据中提取有意义的特征", "模型的部署"],
                "answer": "从原始数据中提取有意义的特征",
                "category": "数据处理与特征工程"
            },
            {
                "id": 67,
                "type": "single",
                "title": "下列哪个算法通常用于分类问题中的特征选择？",
                "options": ["决策树", "PCA（主成分分析）", "K-均值聚类", "线性回归"],
                "answer": "决策树",
                "category": "数据处理与特征工程"
            },
            {
                "id": 68,
                "type": "single",
                "title": "集成学习通过结合多个学习器的预测结果来提高整体性能，这种方法属于哪种策略？",
                "options": ["监督学习", "弱学习", "规则学习", "模型融合"],
                "answer": "模型融合",
                "category": "机器学习分类与算法"
            },
            {
                "id": 69,
                "type": "single",
                "title": "以下哪个指标用于评估分类模型的性能时，考虑到了类别不平衡的问题？",
                "options": ["准确率", "精确率", "召回率", "F1分数"],
                "answer": "F1分数",
                "category": "模型训练与评估"
            },
            {
                "id": 70,
                "type": "single",
                "title": "在强化学习中，智能体通过什么来优化其行为？",
                "options": ["奖励函数", "损失函数", "梯度下降", "决策树"],
                "answer": "奖励函数",
                "category": "强化学习"
            },
            {
                "id": 71,
                "type": "single",
                "title": "以下哪项是机器学习中的无监督学习任务？",
                "options": ["图像分类", "聚类分析", "情感分析", "回归分析"],
                "answer": "聚类分析",
                "category": "机器学习分类与算法"
            },
            {
                "id": 72,
                "type": "single",
                "title": "在机器学习中，梯度下降算法主要用于什么？",
                "options": ["数据的收集", "模型的训练", "数据的清洗", "模型的评估"],
                "answer": "模型的训练",
                "category": "模型训练与评估"
            },
            {
                "id": 73,
                "type": "single",
                "title": "以下哪项是机器学习中常用的正则化技术之一？",
                "options": ["L1正则化", "决策边界", "梯度提升", "逻辑回归"],
                "answer": "L1正则化",
                "category": "模型训练与评估"
            },
            {
                "id": 74,
                "type": "single",
                "title": "在机器学习中，过拟合通常发生在什么情况？",
                "options": ["模型太复杂，训练数据太少", "模型太简单，训练数据太多", "数据集完全随机", "使用了不合适的激活函数"],
                "answer": "模型太复杂，训练数据太少",
                "category": "模型训练与评估"
            },
            {
                "id": 75,
                "type": "single",
                "title": "以下哪个算法是基于树的集成学习算法之一？",
                "options": ["随机森林", "线性回归", "K-近邻", "神经网络"],
                "answer": "随机森林",
                "category": "机器学习分类与算法"
            },
            {
                "id": 76,
                "type": "single",
                "title": "在机器学习中，确保数据质量的关键步骤之一是？",
                "options": ["初始化模型参数", "提取新特征", "数据清洗", "损失函数最小化"],
                "answer": "数据清洗",
                "category": "数据处理与特征工程"
            },
            {
                "id": 77,
                "type": "single",
                "title": "监督学习中，数据通常被分为哪两部分？",
                "options": ["训练集和验证集", "输入特征和输出标签", "验证集和测试集", "数据集和标签集"],
                "answer": "输入特征和输出标签",
                "category": "机器学习分类与算法"
            },
            {
                "id": 78,
                "type": "single",
                "title": "数据标注在机器学习的哪个阶段尤为重要？",
                "options": ["模型评估", "特征工程", "数据预处理", "模型训练"],
                "answer": "数据预处理",
                "category": "数据处理与特征工程"
            },
            {
                "id": 79,
                "type": "single",
                "title": "下列哪项不是数据清洗的常用方法？",
                "options": ["处理缺失值", "转换数据类型", "去除异常值", "初始化模型参数"],
                "answer": "初始化模型参数",
                "category": "数据处理与特征工程"
            },
            {
                "id": 80,
                "type": "single",
                "title": "数据分割时，以下哪个集合通常用于评估模型的最终性能？",
                "options": ["训练集", "验证集", "测试集", "验证集和测试集"],
                "answer": "测试集",
                "category": "模型训练与评估"
            },
            {
                "id": 81,
                "type": "single",
                "title": "在数据标注过程中，为每个样本分配的输出值被称为？",
                "options": ["特征", "权重", "损失", "标签"],
                "answer": "标签",
                "category": "数据处理与特征工程"
            },
            {
                "id": 82,
                "type": "single",
                "title": "数据代表性不足可能导致的问题是？",
                "options": ["过拟合", "欠拟合", "收敛速度过慢", "模型复杂度过高"],
                "answer": "欠拟合",
                "category": "模型训练与评估"
            },
            {
                "id": 83,
                "type": "single",
                "title": "下列哪项不是数据收集时应考虑的因素？",
                "options": ["数据源的可靠性", "数据的隐私保护", "模型的复杂度", "数据的完整性"],
                "answer": "模型的复杂度",
                "category": "数据处理与特征工程"
            },
            {
                "id": 84,
                "type": "single",
                "title": "数据清洗中，处理缺失值的一种常用方法是？",
                "options": ["删除包含缺失值的行或列", "使用均值、中位数或众数填充", "将缺失值视为新特征", "停止模型训练"],
                "answer": "删除包含缺失值的行或列",
                "category": "数据处理与特征工程"
            },
            {
                "id": 85,
                "type": "single",
                "title": "数据的泛化能力主要取决于？",
                "options": ["模型的复杂度", "数据的多样性", "算法的先进性", "损失函数的选择"],
                "answer": "数据的多样性",
                "category": "模型训练与评估"
            },
            {
                "id": 86,
                "type": "single",
                "title": "监督学习中，输入特征与输出标签之间的关系是通过什么来学习的？",
                "options": ["损失函数", "决策树", "神经网络", "训练过程"],
                "answer": "训练过程",
                "category": "机器学习分类与算法"
            },
            {
                "id": 87,
                "type": "single",
                "title": "数据标注的准确性对模型的什么能力影响最大？",
                "options": ["泛化能力", "收敛速度", "预测精度", "特征提取"],
                "answer": "预测精度",
                "category": "数据处理与特征工程"
            },
            {
                "id": 88,
                "type": "single",
                "title": "在数据预处理阶段，处理噪声数据的主要目的是？",
                "options": ["提高模型训练速度", "降低模型的复杂度", "提高模型的预测准确性", "减少数据存储空间"],
                "answer": "提高模型的预测准确性",
                "category": "数据处理与特征工程"
            },
            {
                "id": 89,
                "type": "single",
                "title": "下列哪项不属于数据清洗的范畴？",
                "options": ["缺失值处理", "异常值检测", "特征选择", "噪声处理"],
                "answer": "特征选择",
                "category": "数据处理与特征工程"
            },
            {
                "id": 90,
                "type": "single",
                "title": "数据标注的自动化程度受什么因素影响最大？",
                "options": ["数据集的大小", "数据的复杂性", "标注工具的效率", "模型的训练时间"],
                "answer": "数据的复杂性",
                "category": "数据处理与特征工程"
            },
            {
                "id": 91,
                "type": "single",
                "title": "在数据分割时，为什么需要设置验证集？",
                "options": ["仅用于训练模型", "评估模型在未见过的数据上的表现", "替代测试集进行最终评估", "加速模型训练过程"],
                "answer": "评估模型在未见过的数据上的表现",
                "category": "模型训练与评估"
            },
            {
                "id": 92,
                "type": "single",
                "title": "数据的标签化在哪些类型的机器学习任务中尤为重要？",
                "options": ["无监督学习", "半监督学习", "监督学习", "强化学习"],
                "answer": "监督学习",
                "category": "机器学习分类与算法"
            },
            {
                "id": 93,
                "type": "single",
                "title": "数据质量对模型性能的影响主要体现在哪些方面？",
                "options": ["模型的收敛速度", "模型的复杂度", "模型的预测精度", "模型的泛化能力"],
                "answer": "模型的泛化能力",
                "category": "模型训练与评估"
            },
            {
                "id": 94,
                "type": "single",
                "title": "下列哪项不是数据清洗和预处理阶段需要完成的任务？",
                "options": ["数据标注", "缺失值处理", "噪声处理", "模型评估"],
                "answer": "模型评估",
                "category": "数据处理与特征工程"
            },
            {
                "id": 95,
                "type": "single",
                "title": "数据多样性对防止哪种问题有重要作用？",
                "options": ["欠拟合", "过拟合", "收敛速度过慢", "损失函数波动"],
                "answer": "过拟合",
                "category": "模型训练与评估"
            },
            {
                "id": 96,
                "type": "single",
                "title": "机器学习的基本要素不包括以下哪一项？",
                "options": ["模型", "特征", "规则", "算法"],
                "answer": "规则",
                "category": "机器学习基础"
            },
            {
                "id": 97,
                "type": "single",
                "title": "哪种机器学习算法常用于分类任务，并可以输出样本属于各类的概率？",
                "options": ["线性回归", "支持向量机", "逻辑回归", "决策树"],
                "answer": "逻辑回归",
                "category": "机器学习分类与算法"
            },
            {
                "id": 98,
                "type": "single",
                "title": "模型的假设空间是指什么？",
                "options": ["模型能够表示的所有可能函数的集合", "数据的特征向量集合", "算法的复杂度", "损失函数的种类"],
                "answer": "模型能够表示的所有可能函数的集合",
                "category": "机器学习基础"
            },
            {
                "id": 99,
                "type": "single",
                "title": "下列哪个是评估模型好坏的常用准则？",
                "options": ["准确率", "损失函数", "数据集大小", "算法执行时间"],
                "answer": "损失函数",
                "category": "模型训练与评估"
            },
            {
                "id": 100,
                "type": "single",
                "title": "哪种算法特别适合于处理非线性关系和高维数据？",
                "options": ["朴素贝叶斯", "神经网络", "决策树", "线性回归"],
                "answer": "神经网络",
                "category": "深度学习与神经网络"
            },
            // ... 更多单选题（省略部分题目以保持代码简洁）

            // 多选题（101-130题）
            {
                "id": 101,
                "type": "multiple",
                "title": "LDA模型在做参数估计时，最常用的方法是？（多选）",
                "options": ["Gibbs采样方法", "变分推断", "梯度下降", "Beam search"],
                "answer": ["Gibbs采样方法", "变分推断"],
                "category": "机器学习分类与算法"
            },
            {
                "id": 102,
                "type": "multiple",
                "title": "以下关于逻辑斯蒂回归模型的描述正确的是？（多选）",
                "options": ["针对分类的可能性进行建模，不仅能预测出类别，还可以得到属于该类别的概率", "直接对分类的可能性进行建模，无需事先假设数据分布", "模型本质仍然是一个线性模型，实现相对简单", "逻辑斯蒂回归模型是线性回归模型"],
                "answer": ["针对分类的可能性进行建模，不仅能预测出类别，还可以得到属于该类别的概率", "直接对分类的可能性进行建模，无需事先假设数据分布", "模型本质仍然是一个线性模型，实现相对简单", "逻辑斯蒂回归模型是线性回归模型"],
                "category": "机器学习分类与算法"
            },
            {
                "id": 103,
                "type": "multiple",
                "title": "条件随机场需要解决的关键问题有？（多选）",
                "options": ["特征函数的选择", "参数估计", "约束条件", "模型推断"],
                "answer": ["特征函数的选择", "参数估计", "模型推断"],
                "category": "机器学习分类与算法"
            },
            {
                "id": 104,
                "type": "multiple",
                "title": "基于搜索评分的方法，关键点在于？（多选）",
                "options": ["确定合适的搜索策略", "确定搜索优先级", "确定评分函数", "确定选择策略"],
                "answer": ["确定合适的搜索策略", "确定评分函数"],
                "category": "机器学习分类与算法"
            },
            {
                "id": 105,
                "type": "multiple",
                "title": "基于约束的方法通过统计独立性测试来学习结点间的？（多选）",
                "options": ["独立性", "依赖性", "完备性", "相关性"],
                "answer": ["独立性", "相关性"],
                "category": "机器学习分类与算法"
            },
            {
                "id": 106,
                "type": "multiple",
                "title": "在数据不完备时，贝叶斯网络的参数学习方法有？（多选）",
                "options": ["高斯逼近", "最大似然估计方法", "蒙特卡洛方法", "拉普拉斯近似"],
                "answer": ["高斯逼近", "蒙特卡洛方法", "拉普拉斯近似"],
                "category": "机器学习分类与算法"
            },
            {
                "id": 107,
                "type": "multiple",
                "title": "隐马尔可夫模型的三个基本问题是？（多选）",
                "options": ["估值问题", "状态更新", "寻找状态序列", "学习模型参数"],
                "answer": ["估值问题", "寻找状态序列", "学习模型参数"],
                "category": "机器学习分类与算法"
            },
            {
                "id": 108,
                "type": "multiple",
                "title": "通常有哪几种训练神经网络的优化方法？（多选）",
                "options": ["梯度下降法", "随机梯度下降法", "小批量随机梯度下降法", "集成法"],
                "answer": ["梯度下降法", "随机梯度下降法", "小批量随机梯度下降法"],
                "category": "深度学习与神经网络"
            },
            {
                "id": 109,
                "type": "multiple",
                "title": "为什么循环神经网络可以用来实现自动问答？（多选）",
                "options": ["因为自动问答可以看成是一种序列到序列的转换", "因为循环神经网要比卷积神经网更强大", "因为循环神经网络能够处理变长输入", "因为卷积神经网络不能处理字符输入"],
                "answer": ["因为自动问答可以看成是一种序列到序列的转换", "因为循环神经网络能够处理变长输入"],
                "category": "深度学习与神经网络"
            },
            {
                "id": 110,
                "type": "multiple",
                "title": "以下关于蒙特卡洛方法描述正确的是？（多选）",
                "options": ["蒙特卡洛方法计算值函数可以采用First-visit方法", "蒙特卡洛方法方差很大", "蒙特卡洛方法计算值函数可以采用Every-visit方法", "蒙特卡洛方法偏差很大"],
                "answer": ["蒙特卡洛方法计算值函数可以采用First-visit方法", "蒙特卡洛方法方差很大", "蒙特卡洛方法计算值函数可以采用Every-visit方法"],
                "category": "强化学习"
            },
            {
                "id": 111,
                "type": "multiple",
                "title": "在Q-learning中，以下说法正确的是？（多选）",
                "options": ["在状态s'时计算的Q(s',a')，对应的动作a'并没有真正执行", "在状态s'时计算的Q(s',a')，同时也执行了动作a'", "更新中，Q的真实值为r+γ(maxQ(s',a'))", "更新中，Q的真实值为Q(s,a)"],
                "answer": ["在状态s'时计算的Q(s',a')，对应的动作a'并没有真正执行", "更新中，Q的真实值为r+γ(maxQ(s',a'))"],
                "category": "强化学习"
            },
            {
                "id": 112,
                "type": "multiple",
                "title": "Sarsa与Q-learning的区别是？（多选）",
                "options": ["Sarsa是off-policy，而Q-learning是on-policy", "Sarsa是on-policy，而Q-learning是off-policy", "Q-learning更新时下一个动作未执行，Sarsa下一个动作已确定", "Q-learning是保守算法，sarsa是贪婪算法"],
                "answer": ["Sarsa是on-policy，而Q-learning是off-policy", "Q-learning更新时下一个动作未执行，Sarsa下一个动作已确定"],
                "category": "强化学习"
            },
            {
                "id": 113,
                "type": "multiple",
                "title": "Q-learning与Sarsa相同的地方是？（多选）",
                "options": ["都使用了ε-greedy等策略进行探索", "都用q-table存储状态动作对", "更新公式相同", "两者都可以找到最优的策略"],
                "answer": ["都使用了ε-greedy等策略进行探索", "都用q-table存储状态动作对"],
                "category": "强化学习"
            },
            {
                "id": 114,
                "type": "multiple",
                "title": "关于经验池（experience replay）叙述正确的是？（多选）",
                "options": ["为了缩小样本量，让样本输入到神经网络中", "打破样本之间的连续性", "每次更新时在经验池中按顺序采样样本", "每次更新时随机采样样本"],
                "answer": ["打破样本之间的连续性", "每次更新时随机采样样本"],
                "category": "强化学习"
            },
            {
                "id": 115,
                "type": "multiple",
                "title": "关于DQN说法正确的是？（多选）",
                "options": ["网络常用卷积或全连接网络，目的是提取图像特征", "Atari游戏中常将连续4帧图像作为一个state输入", "网络的输出是动作", "网络的输出是Q值"],
                "answer": ["网络常用卷积或全连接网络，目的是提取图像特征", "Atari游戏中常将连续4帧图像作为一个state输入", "网络的输出是Q值"],
                "category": "深度学习与神经网络"
            },
            {
                "id": 116,
                "type": "multiple",
                "title": "人工智能的主要研究内容包括哪些？（多选）",
                "options": ["计算机视觉", "自然语言处理", "语音识别", "专家系统"],
                "answer": ["计算机视觉", "自然语言处理", "语音识别", "专家系统"],
                "category": "人工智能基础"
            },
            {
                "id": 117,
                "type": "multiple",
                "title": "机器学习中常用的算法有哪些？（多选）",
                "options": ["决策树", "支持向量机(SVM)", "随机森林", "神经网络"],
                "answer": ["决策树", "支持向量机(SVM)", "随机森林", "神经网络"],
                "category": "机器学习分类与算法"
            },
            {
                "id": 118,
                "type": "multiple",
                "title": "机器学习中的数据预处理主要包括哪些步骤？（多选）",
                "options": ["数据清洗", "特征提取", "数据转换", "数据划分"],
                "answer": ["数据清洗", "特征提取", "数据转换", "数据划分"],
                "category": "数据处理与特征工程"
            },
            {
                "id": 119,
                "type": "multiple",
                "title": "人工智能在医疗健康领域的应用主要包括哪些？（多选）",
                "options": ["疾病诊断", "药物研发", "机器人手术", "患者监测"],
                "answer": ["疾病诊断", "药物研发", "机器人手术", "患者监测"],
                "category": "人工智能应用"
            },
            {
                "id": 120,
                "type": "multiple",
                "title": "人工智能在金融领域的应用主要包括哪些？（多选）",
                "options": ["信用评分", "欺诈检测", "自动化交易", "客户服务"],
                "answer": ["信用评分", "欺诈检测", "自动化交易", "客户服务"],
                "category": "人工智能应用"
            },
            {
                "id": 121,
                "type": "multiple",
                "title": "机器学习中，以下哪些方法用于评估模型的性能？（多选）",
                "options": ["偏差", "方差", "R²分数", "准确率"],
                "answer": ["偏差", "方差", "R²分数", "准确率"],
                "category": "模型训练与评估"
            },
            {
                "id": 122,
                "type": "multiple",
                "title": "人工智能的核心技术包括哪些？（多选）",
                "options": ["神经网络", "自然语言处理", "计算机视觉", "专家系统"],
                "answer": ["神经网络", "自然语言处理", "计算机视觉", "专家系统"],
                "category": "人工智能基础"
            },
            {
                "id": 123,
                "type": "multiple",
                "title": "人工智能和机器学习在哪些领域有广泛应用？（多选）",
                "options": ["医疗保健", "金融", "交通", "教育"],
                "answer": ["医疗保健", "金融", "交通", "教育"],
                "category": "人工智能应用"
            },
            {
                "id": 124,
                "type": "multiple",
                "title": "在人工智能中，哪些技术属于计算机视觉领域？（多选）",
                "options": ["人脸识别", "语音识别", "自动驾驶", "图像识别"],
                "answer": ["人脸识别", "自动驾驶", "图像识别"],
                "category": "人工智能基础"
            },
            {
                "id": 125,
                "type": "multiple",
                "title": "机器学习中，以下哪些方法用于防止过拟合？（多选）",
                "options": ["增加数据集的大小", "引入正则化项", "减少模型的特征数量", "交叉验证"],
                "answer": ["增加数据集的大小", "引入正则化项", "减少模型的特征数量", "交叉验证"],
                "category": "模型训练与评估"
            },
            {
                "id": 126,
                "type": "multiple",
                "title": "处理类别不平衡数据集的常用策略有？（多选）",
                "options": ["过采样", "欠采样", "合成少数类过采样技术（SMOTE）", "代价敏感学习"],
                "answer": ["过采样", "欠采样", "合成少数类过采样技术（SMOTE）", "代价敏感学习"],
                "category": "数据处理与特征工程"
            },
            {
                "id": 127,
                "type": "multiple",
                "title": "深度学习中的常见架构有哪些？（多选）",
                "options": ["卷积神经网络（CNN）", "循环神经网络（RNN）", "长短时记忆网络（LSTM）", "朴素贝叶斯"],
                "answer": ["卷积神经网络（CNN）", "循环神经网络（RNN）", "长短时记忆网络（LSTM）"],
                "category": "深度学习与神经网络"
            },
            {
                "id": 128,
                "type": "multiple",
                "title": "强化学习的核心要素包括哪些？（多选）",
                "options": ["智能体（Agent）", "环境（Environment）", "奖励（Reward）", "策略（Policy）"],
                "answer": ["智能体（Agent）", "环境（Environment）", "奖励（Reward）", "策略（Policy）"],
                "category": "强化学习"
            },
            {
                "id": 129,
                "type": "multiple",
                "title": "特征工程的主要步骤包括哪些？（多选）",
                "options": ["特征提取", "特征选择", "特征转换", "特征规范化"],
                "answer": ["特征提取", "特征选择", "特征转换", "特征规范化"],
                "category": "数据处理与特征工程"
            },
            {
                "id": 130,
                "type": "multiple",
                "title": "人工智能未来的发展趋势可能包括哪些？（多选）",
                "options": ["更强大的算法", "跨领域融合", "智能化应用普及", "伦理与隐私保护"],
                "answer": ["更强大的算法", "跨领域融合", "智能化应用普及", "伦理与隐私保护"],
                "category": "人工智能发展"
            },

            // ... 更多多选题（省略部分题目以保持代码简洁）

            // 简答题（131-146题）
            {
                "id": 131,
                "type": "essay",
                "title": "什么是无监督学习？",
                "answer": "无监督学习是一种机器学习方法，它使用没有标签的数据集进行训练，目标是发现数据中的内在结构或模式，如聚类、降维等，无需人工提供样本的类别或目标值。",
                "category": "机器学习分类与算法"
            },
            {
                "id": 132,
                "type": "essay",
                "title": "无监督学习的典型应用有哪些？",
                "answer": "无监督学习的典型应用包括客户分群（如根据消费习惯划分客户群体）、异常检测（如金融交易中的 fraud 识别）、主题建模（如文本数据中的话题提取）、社交网络分析（如识别社交关系中的社区）、数据降维（如PCA用于高维数据可视化）等。",
                "category": "机器学习分类与算法"
            },
            {
                "id": 133,
                "type": "essay",
                "title": "K-均值聚类算法的基本思想是什么？",
                "answer": "K-均值聚类算法的基本思想是：预先指定簇的数量K，通过迭代方式将数据集分成K个簇，使每个数据点到其所属簇的中心（簇心，通常为簇内数据的均值）的距离平方和最小，最终实现簇内数据相似度高、簇间数据相似度低的聚类效果。",
                "category": "机器学习分类与算法"
            },
            {
                "id": 134,
                "type": "essay",
                "title": "DBSCAN算法与K-均值聚类的主要区别是什么？",
                "answer": "DBSCAN与K-均值聚类的核心区别的在于：1. 簇定义方式：DBSCAN是基于密度的聚类算法（通过“核心点”“边界点”“噪声点”划分簇），能识别任意形状的簇；K-均值基于距离（簇心与数据点的距离），仅适用于凸形簇。2. 参数依赖：DBSCAN无需预先指定簇数量，K-均值必须提前确定K值。3. 噪声处理：DBSCAN能自动识别并排除噪声点，K-均值对噪声和离群点敏感，易影响簇心计算。",
                "category": "机器学习分类与算法"
            },
            {
                "id": 135,
                "type": "essay",
                "title": "什么是主成分分析（PCA）？",
                "answer": "主成分分析（PCA）是一种常用的无监督数据降维技术，核心思想是通过线性变换将原始高维数据映射到低维空间（主成分空间），且保证映射后的数据尽可能保留原始数据的主要信息（即方差最大）。每个主成分是原始特征的线性组合，且主成分之间相互正交，避免信息冗余。",
                "category": "数据处理与特征工程"
            },
            {
                "id": 136,
                "type": "essay",
                "title": "PCA在进行数据降维时如何确定主成分的数量？",
                "answer": "PCA通过计算每个主成分的“方差贡献率”（该主成分的方差占所有主成分总方差的比例）来确定主成分数量，常用方法包括：1. 设定方差贡献率阈值（如累计方差贡献率达到80%-90%），选择满足该阈值的前几个主成分；2. 基于“肘部法则”，绘制方差贡献率随主成分数量变化的曲线，选择曲线由陡变缓的“肘部”对应的主成分数量；3. 根据业务需求或后续模型要求，直接指定主成分数量（如降维至2维/3维用于可视化）。",
                "category": "数据处理与特征工程"
            },
            {
                "id": 137,
                "type": "essay",
                "title": "无监督学习中的聚类评估有哪些常用指标？",
                "answer": "无监督学习中聚类评估的常用指标包括：1. 轮廓系数（Silhouette Coefficient）：衡量每个数据点与所属簇的相似度（内聚性）和与其他簇的相似度（分离性），取值范围[-1,1]，越接近1聚类效果越好；2. Calinski-Harabasz指数：计算簇间离均差平方和与簇内离均差平方和的比值，比值越大说明簇间差异大、簇内差异小，聚类效果越好；3. Davies-Bouldin指数：衡量不同簇的相似度（簇内直径与簇间距离的比值），取值越小聚类效果越好。",
                "category": "模型训练与评估"
            },
            {
                "id": 138,
                "type": "essay",
                "title": "无监督学习如何用于异常检测？",
                "answer": "无监督学习通过识别数据中“不符合整体模式”的样本实现异常检测，核心思路是：假设正常数据服从特定分布或具有相似结构，异常数据偏离该分布/结构。常用方法包括：1. 基于密度的方法（如DBSCAN）：将低密度区域的样本判定为异常；2. 基于距离的方法（如K近邻）：计算样本与周围样本的距离，距离过大则为异常；3. 基于聚类的方法（如K-均值）：将不属于任何簇或簇内占比极低的样本判定为异常；4. 基于降维的方法（如PCA）：通过重构误差判断，重构误差大的样本为异常（如Autoencoder用于异常检测）。",
                "category": "机器学习分类与算法"
            },
            {
                "id": 139,
                "type": "essay",
                "title": "层次聚类算法的基本思想是什么？",
                "answer": "层次聚类算法的基本思想是通过“合并”或“分裂”逐步构建簇的层次结构：1. 凝聚式（自底向上）：初始时每个样本为一个独立簇，每次将相似度最高的两个簇合并，重复该过程直到所有样本合并为一个簇；2. 分裂式（自顶向下）：初始时所有样本为一个簇，每次将相似度最低的簇分裂为两个子簇，重复该过程直到每个样本为一个独立簇。最终可通过“树状图（Dendrogram）”展示簇的层次关系，根据业务需求选择合适的层次划分簇。",
                "category": "机器学习分类与算法"
            },
            {
                "id": 140,
                "type": "essay",
                "title": "什么是自编码器（Autoencoder）？",
                "answer": "自编码器是一种无监督学习的神经网络模型，结构分为“编码器”和“解码器”两部分：1. 编码器：将高维输入数据映射到低维隐藏层（编码层），学习输入数据的压缩表示（特征）；2. 解码器：将低维编码映射回高维输出，目标是使输出尽可能接近输入（最小化重构误差）。自编码器常用于数据降维、特征学习、图像去噪、数据生成等场景，变体包括稀疏自编码器、卷积自编码器等。",
                "category": "深度学习与神经网络"
            },
            {
                "id": 141,
                "type": "essay",
                "title": "如何评估无监督学习模型的性能？",
                "answer": "无监督学习模型（如聚类、降维模型）的性能评估需结合“数据内在结构”和“业务需求”，常用方法包括：1. 内在指标：基于数据本身的特征评估，如聚类的轮廓系数、Calinski-Harabasz指数，降维的重构误差（如Autoencoder）；2. 外在指标：若有少量标签数据，可通过“聚类纯度”“调整兰德指数（ARI）”等将聚类结果与真实标签对比；3. 业务指标：结合实际应用场景评估，如客户分群模型需验证分群结果是否能指导营销决策，异常检测模型需验证异常识别的准确率（如金融 fraud 检测的召回率）。",
                "category": "模型训练与评估"
            },
            {
                "id": 142,
                "type": "essay",
                "title": "什么是t-SNE算法？",
                "answer": "t-SNE（t-distributed Stochastic Neighbor Embedding）是一种用于高维数据可视化的无监督学习算法，核心思想是：1. 高维空间中，通过高斯分布计算样本间的相似度（相似样本相似度高，不相似样本相似度低）；2. 低维空间中，通过t分布（减少异常值影响）计算样本间的相似度；3. 最小化高维与低维空间中样本相似度分布的KL散度，实现将高维数据映射到2维/3维空间，同时保留数据的局部结构（如相近样本在低维空间仍相近），常用于高维数据（如图像、文本特征）的可视化分析。",
                "category": "数据处理与特征工程"
            },
            {
                "id": 143,
                "type": "essay",
                "title": "无监督学习中的特征学习有哪些方法？",
                "answer": "无监督学习中的特征学习方法旨在从原始数据中自动提取有意义的特征，无需人工标注，常用方法包括：1. 自编码器（Autoencoder）：通过重构输入学习数据的压缩特征；2. 稀疏编码（Sparse Coding）：学习稀疏的特征表示（多数特征值为0，少数非零特征反映关键信息）；3. 受限玻尔兹曼机（RBM）：一种生成式神经网络，用于学习数据的概率分布和低维特征；4. 聚类驱动的特征学习（如K-均值）：将聚类结果作为特征（如样本所属簇的标签）；5. 降维方法（如PCA、t-SNE）：将高维数据映射到低维空间，低维表示即为特征。",
                "category": "数据处理与特征工程"
            },
            {
                "id": 144,
                "type": "essay",
                "title": "无监督学习如何应用于推荐系统？",
                "answer": "无监督学习在推荐系统中的应用主要通过分析用户/物品的内在结构实现个性化推荐，常用场景包括：1. 用户分群：通过K-均值、DBSCAN等聚类算法将用户按行为（如浏览、购买记录）分群，对同一群用户推荐相似物品；2. 物品聚类：将物品按属性（如商品类别、内容特征）聚类，向购买过某类物品的用户推荐同簇其他物品；3. 协同过滤（无监督版）：通过用户-物品交互矩阵的降维（如PCA）或关联规则学习，挖掘用户潜在偏好，如基于用户交互的相似性推荐“相似用户喜欢的物品”；4. 内容特征提取：通过自编码器、稀疏编码提取物品内容（如文本、图像）的特征，实现“基于内容的推荐”。",
                "category": "人工智能应用"
            },
            {
                "id": 145,
                "type": "essay",
                "title": "无监督学习中的模型选择有哪些考虑因素？",
                "answer": "无监督学习中的模型选择需结合数据特性、任务需求和算法特性，核心考虑因素包括：1. 数据特性：如数据维度（高维数据优先选降维+聚类，如PCA+K-均值）、数据分布（密度不均数据选DBSCAN，凸分布选K-均值）、是否有噪声（噪声多优先选鲁棒性强的模型，如DBSCAN）；2. 任务目标：如目标是可视化（选t-SNE、PCA）、异常检测（选基于密度/距离的模型）、特征学习（选自编码器、RBM）；3. 算法复杂度：如小规模数据可选层次聚类，大规模数据选K-均值（计算效率高）；4. 可解释性：如需要解释聚类结果选K-均值（簇心可解释），无需解释选自编码器等黑箱模型。",
                "category": "机器学习分类与算法"
            },
            {
                "id": 146,
                "type": "essay",
                "title": "什么是谱聚类（Spectral Clustering）？",
                "answer": "谱聚类是一种基于图论的无监督聚类算法，核心思想是将数据聚类问题转化为“图分割”问题，步骤包括：1. 构建图：将每个样本视为图的节点，通过相似度（如高斯核函数）计算节点间的边权重（相似样本边权重高，不相似样本边权重低）；2. 计算拉普拉斯矩阵：基于图的邻接矩阵和度矩阵构建拉普拉斯矩阵，用于刻画图的结构特性；3. 特征值分解：对拉普拉斯矩阵进行特征值分解，选取前K个最小特征值对应的特征向量，构成低维特征矩阵；4. 聚类：对低维特征矩阵使用K-均值等聚类算法，得到最终聚类结果。谱聚类能处理非凸形状簇，对噪声有一定鲁棒性，适用于高维数据或非结构化数据（如图像、文本）。",
                "category": "机器学习分类与算法"
            },
            {
                "id": 147,
                "type": "essay",
                "title": "无监督学习如何帮助解决数据不平衡问题？",
                "answer": "无监督学习通过挖掘数据内在结构，为数据不平衡问题（如少数类样本极少）提供辅助解决方案，常用方式包括：1. 少数类样本扩充：通过无监督生成模型（如自编码器、GAN）学习少数类样本的分布"
            }
            // ... 更多简答题（省略部分题目以保持代码简洁）
        ];

        // 应用状态
        let appState = {
            currentFilter: 'all',
            searchQuery: '',
            wrongQuestions: [],
            practiceMode: false,
            currentQuestions: [...questionBank]
        };

        // DOM 元素
        const questionList = document.getElementById('questionList');
        const filterBtns = document.querySelectorAll('.filter-btn');
        const searchInput = document.getElementById('searchInput');
        const randomBtn = document.getElementById('randomBtn');
        const wrongQuestionsBtn = document.getElementById('wrongQuestionsBtn');
        const practiceModeBtn = document.getElementById('practiceModeBtn');
        const totalCountEl = document.getElementById('totalCount');
        const singleCountEl = document.getElementById('singleCount');
        const multipleCountEl = document.getElementById('multipleCount');
        const essayCountEl = document.getElementById('essayCount');
        const wrongCountEl = document.getElementById('wrongCount');

        // 初始化统计信息
        function initStats() {
            const singleCount = questionBank.filter(q => q.type === 'single').length;
            const multipleCount = questionBank.filter(q => q.type === 'multiple').length;
            const essayCount = questionBank.filter(q => q.type === 'essay').length;

            totalCountEl.textContent = questionBank.length;
            singleCountEl.textContent = singleCount;
            multipleCountEl.textContent = multipleCount;
            essayCountEl.textContent = essayCount;
            wrongCountEl.textContent = appState.wrongQuestions.length;
        }

        // 初始化渲染所有题目
        renderQuestions();

        // 初始化事件监听
        initEventListeners();

        // 初始化统计信息
        initStats();

        // 事件监听初始化
        function initEventListeners() {
            // 筛选按钮事件绑定
            filterBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    // 更新激活状态
                    filterBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    // 更新筛选状态
                    appState.currentFilter = btn.getAttribute('data-type');
                    renderQuestions();
                });
            });

            // 搜索框事件
            searchInput.addEventListener('input', (e) => {
                appState.searchQuery = e.target.value.trim();
                renderQuestions();
            });

            // 随机选题按钮
            randomBtn.addEventListener('click', () => {
                const randomIndex = Math.floor(Math.random() * appState.currentQuestions.length);
                const randomQuestion = appState.currentQuestions[randomIndex];

                // 滚动到随机题目
                const questionElement = document.querySelector(`[data-id="${randomQuestion.id}"]`);
                if (questionElement) {
                    questionElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // 添加高亮效果
                    questionElement.style.backgroundColor = '#f0f8ff';
                    setTimeout(() => {
                        questionElement.style.backgroundColor = '';
                    }, 2000);
                }
            });

            // 查看错题按钮
            wrongQuestionsBtn.addEventListener('click', () => {
                if (appState.wrongQuestions.length === 0) {
                    alert('您还没有标记任何错题！');
                    return;
                }

                // 切换错题显示
                if (wrongQuestionsBtn.textContent === '查看错题') {
                    appState.currentQuestions = appState.wrongQuestions;
                    wrongQuestionsBtn.textContent = '返回全部题目';
                    renderQuestions();
                    updateStats();
                } else {
                    appState.currentQuestions = [...questionBank];
                    wrongQuestionsBtn.textContent = '查看错题';
                    renderQuestions();
                }
            });

            // 练习模式按钮
            practiceModeBtn.addEventListener('click', () => {
                appState.practiceMode = !appState.practiceMode;
                practiceModeBtn.textContent = appState.practiceMode ? '退出练习模式' : '练习模式';
                renderQuestions();
            });
        }

        // 渲染题目函数
        function renderQuestions() {
            // 清空列表
            questionList.innerHTML = '';

            // 筛选题目
            let filteredQuestions = [...appState.currentQuestions];

            // 应用题型筛选
            if (appState.currentFilter !== 'all') {
                filteredQuestions = filteredQuestions.filter(q => q.type === appState.currentFilter);
            }

            // 应用搜索筛选
            if (appState.searchQuery) {
                const query = appState.searchQuery.toLowerCase();
                filteredQuestions = filteredQuestions.filter(q =>
                    q.title.toLowerCase().includes(query) ||
                    (q.options && q.options.some(opt => opt.toLowerCase().includes(query))) ||
                    q.answer.toLowerCase().includes(query) ||
                    q.category.toLowerCase().includes(query)
                );
            }

            // 无匹配题目时显示提示
            if (filteredQuestions.length === 0) {
                const emptyTip = document.createElement('div');
                emptyTip.style.textAlign = 'center';
                emptyTip.style.padding = '50px 0';
                emptyTip.style.color = '#7f8c8d';
                emptyTip.innerHTML = '<p>暂无匹配题目</p>';
                questionList.appendChild(emptyTip);
                return;
            }

            // 渲染每个题目
            filteredQuestions.forEach(question => {
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                questionCard.setAttribute('data-type', question.type);
                questionCard.setAttribute('data-id', question.id);

                // 题型文本映射
                const typeTextMap = {
                    single: '单选题',
                    multiple: '多选题',
                    essay: '简答题'
                };

                // 构建题目HTML
                let questionHTML = `
                            <div class="question-header">
                                <span class="question-type type-${question.type}">${typeTextMap[question.type]}</span>
                                <span class="question-id">第 ${question.id} 题</span>
                                ${appState.practiceMode ? '<span class="mode-indicator">练习模式</span>' : ''}
                                <span class="category-tag">${question.category}</span>
                            </div>
                            <div class="question-title">${question.title}</div>
                        `;

                // 单选题/多选题添加选项
                if (question.type === 'single' || question.type === 'multiple') {
                    questionHTML += `<div class="options">`;
                    question.options.forEach((option, index) => {
                        const optionType = question.type === 'single' ? 'radio' : 'checkbox';
                        const optionId = `q${question.id}_opt${index}`;
                        questionHTML += `
                                    <div class="option-item">
                                        <input type="${optionType}" name="q${question.id}" id="${optionId}" data-question-id="${question.id}">
                                        <label for="${optionId}">${option}</label>
                                    </div>
                                `;
                    });
                    questionHTML += `</div>`;
                }

                // 添加答案区域和按钮
                const isWrong = appState.wrongQuestions.some(q => q.id === question.id);
                questionHTML += `
                            <div class="btn-group">
                                <button class="show-answer-btn" data-id="${question.id}">查看答案</button>
                                ${!appState.practiceMode ?
                        `<button class="mark-wrong-btn" data-id="${question.id}">${isWrong ? '取消错题' : '标记错题'}</button>` :
                        ''
                    }
                            </div>
                            <div class="answer-container" id="answer_${question.id}">
                                <span class="answer-label">正确答案：</span>
                                <div class="answer-content">${formatAnswer(question)}</div>
                            </div>
                        `;

                questionCard.innerHTML = questionHTML;
                questionList.appendChild(questionCard);
            });

            // 绑定查看答案按钮事件
            bindAnswerBtnEvents();

            // 绑定标记错题按钮事件
            bindWrongBtnEvents();

            // 绑定选项选择事件（练习模式）
            if (appState.practiceMode) {
                bindOptionEvents();
            }
        }

        // 格式化答案（适配不同题型）
        function formatAnswer(question) {
            if (question.type === 'single') {
                return question.answer; // 单选答案直接显示
            } else if (question.type === 'multiple') {
                return Array.isArray(question.answer) ? question.answer.join('、') : question.answer; // 多选答案用顿号分隔
            } else if (question.type === 'essay') {
                return question.answer; // 简答答案直接显示（支持换行）
            }
        }

        // 绑定查看答案按钮事件
        function bindAnswerBtnEvents() {
            const answerBtns = document.querySelectorAll('.show-answer-btn');
            answerBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const questionId = btn.getAttribute('data-id');
                    const answerContainer = document.getElementById(`answer_${questionId}`);
                    // 切换答案显示/隐藏
                    answerContainer.classList.toggle('show');
                    btn.textContent = answerContainer.classList.contains('show') ? '隐藏答案' : '查看答案';
                });
            });
        }

        // 绑定标记错题按钮事件
        function bindWrongBtnEvents() {
            const wrongBtns = document.querySelectorAll('.mark-wrong-btn');
            wrongBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const questionId = parseInt(btn.getAttribute('data-id'));
                    const question = questionBank.find(q => q.id === questionId);

                    if (!question) return;

                    const isAlreadyWrong = appState.wrongQuestions.some(q => q.id === questionId);

                    if (isAlreadyWrong) {
                        // 从错题本中移除
                        appState.wrongQuestions = appState.wrongQuestions.filter(q => q.id !== questionId);
                        btn.textContent = '标记错题';
                    } else {
                        // 添加到错题本
                        appState.wrongQuestions.push(question);
                        btn.textContent = '取消错题';
                    }

                    // 更新统计信息
                    updateStats();

                    // 如果当前正在查看错题，更新显示
                    if (wrongQuestionsBtn.textContent === '返回全部题目') {
                        appState.currentQuestions = appState.wrongQuestions;
                        renderQuestions();
                    }
                });
            });
        }

        // 绑定选项选择事件（练习模式）
        function bindOptionEvents() {
            const optionInputs = document.querySelectorAll('.options input');
            optionInputs.forEach(input => {
                input.addEventListener('change', (e) => {
                    const questionId = parseInt(e.target.getAttribute('data-question-id'));
                    const question = questionBank.find(q => q.id === questionId);

                    if (!question) return;

                    // 获取用户选择的答案
                    const userAnswers = getSelectedOptions(questionId, question.type);

                    // 验证答案
                    const isCorrect = checkAnswer(question, userAnswers);

                    // 显示结果
                    const answerContainer = document.getElementById(`answer_${questionId}`);
                    const showAnswerBtn = document.querySelector(`.show-answer-btn[data-id="${questionId}"]`);

                    if (isCorrect) {
                        answerContainer.innerHTML = `
                                <span class="answer-label" style="color: #27ae60;">回答正确！</span>
                                <div class="answer-content">${formatAnswer(question)}</div>
                            `;
                    } else {
                        answerContainer.innerHTML = `
                                <span class="answer-label" style="color: #e74c3c;">回答错误！</span>
                                <div class="answer-content">正确答案：${formatAnswer(question)}</div>
                            `;
                    }

                    answerContainer.classList.add('show');
                    showAnswerBtn.textContent = '隐藏答案';
                });
            });
        }

        // 获取用户选择的选项
        function getSelectedOptions(questionId, questionType) {
            const selector = questionType === 'single' ?
                `input[name="q${questionId}"]:checked` :
                `input[name="q${questionId}"]:checked`;

            const selectedInputs = document.querySelectorAll(selector);
            const selectedOptions = [];

            selectedInputs.forEach(input => {
                const label = document.querySelector(`label[for="${input.id}"]`);
                if (label) {
                    selectedOptions.push(label.textContent);
                }
            });

            return selectedOptions;
        }

        // 验证答案
        function checkAnswer(question, userAnswers) {
            if (question.type === 'single') {
                return userAnswers.length === 1 && userAnswers[0] === question.answer;
            } else if (question.type === 'multiple') {
                const correctAnswers = Array.isArray(question.answer) ? question.answer : [question.answer];
                return userAnswers.length === correctAnswers.length &&
                    userAnswers.every(answer => correctAnswers.includes(answer)) &&
                    correctAnswers.every(answer => userAnswers.includes(answer));
            }
            return false; // 简答题在练习模式下不验证
        }

        // 更新统计信息
        function updateStats() {
            wrongCountEl.textContent = appState.wrongQuestions.length;
        }
    </script>
</body>
</html>